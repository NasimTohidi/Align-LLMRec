import pandas as pd
import torch
from torch.utils.data import Dataset
from transformers import AutoTokenizer
from textblob import TextBlob

class AmazonMusicDataset(Dataset):
    def __init__(self, review_path, meta_path, max_len=10):
        # 1. Load data
        reviews = pd.read_json(review_path, lines=True)
        meta = pd.read_json(meta_path, lines=True)
        
        # 2. Apply 5-core filtering 
        self.reviews = self._apply_5core(reviews)
        self.meta = meta[meta['asin'].isin(self.reviews['asin'].unique())]
        
        self.max_len = max_len
        
        # SBERT for metadata, DistilBERT for reviews
        self.tokenizer_meta = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
        self.tokenizer_rev = AutoTokenizer.from_pretrained('distilbert-base-uncased')

    def _apply_5core(self, df):
        """Iteratively retain users and items with >= 5 interactions."""
        while True:
            u_counts = df['user_id'].value_counts()
            i_counts = df['asin'].value_counts()
            # Check if any user or item has < 5 interactions
            if (u_counts < 5).any() or (i_counts < 5).any():
                df = df[df['user_id'].isin(u_counts[u_counts >= 5].index)]
                df = df[df['asin'].isin(i_counts[i_counts >= 5].index)]
            else:
                break
        return df

    def extract_sentiment_score(self, text):
        """Generate the explicit sentiment label s in {0,1}."""
        analysis = TextBlob(text)
        # s=1 for positive, s=0 for negative
        return [1.0] if analysis.sentiment.polarity > 0 else [0.0]

    def __len__(self):
        return len(self.reviews)

    def __getitem__(self, index):
        row = self.reviews.iloc[index]
        
        # Handle cases where metadata might be missing for specific ASINs
        item_meta_rows = self.meta[self.meta['asin'] == row['asin']]
        if not item_meta_rows.empty:
            item_meta = item_meta_rows.iloc[0]
            meta_text = f"{item_meta.get('title', '')} {item_meta.get('description', '')}"
        else:
            meta_text = ""

        # m^R: Affective cues from reviews + explicit sentiment vector 's' 
        review_text = str(row.get('reviewText', ''))
        s = self.extract_sentiment_score(review_text) 

        # Return dict with all components needed for Stage I multi-task loss
        return {
            'seq': torch.tensor(row['history'][-self.max_len:]), # sequential history
            'target_item': torch.tensor(row['target']),
            'meta_text': meta_text,
            'review_text': review_text,
            'sentiment_s': torch.tensor(s, dtype=torch.float32), 
            'is_warm': torch.tensor(1 if row.get('freq', 0) > 10 else 0) # For CL_w/c

        }
